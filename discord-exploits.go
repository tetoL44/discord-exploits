package main

import (
	"bytes"
	"flag"
	"math/rand"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/gabriel-vasile/mimetype"
)

var (
	mode       string
	inputFile  string
	outputFile string

	done     = make(chan response, 1)
	logRed   = color.New(color.FgHiRed)
	logGreen = color.New(color.FgHiGreen)
)

type response int

const (
	responseWrongFileType response = iota
	responseFileNotExist
	responseUnknownError
	responseDone
)

func init() {
	flag.StringVar(&mode, "m", "", "mode you want to use")
	flag.StringVar(&inputFile, "i", "", "input file")
	flag.StringVar(&outputFile, "o", "", "output file, will be random if its not set")

	flag.Parse()
	flag.CommandLine.SetOutput(os.Stdout)
	flag.Usage = func() {
		_, file := filepath.Split(os.Args[0])
		logRed.Fprintf(flag.CommandLine.Output(), "Usage of %s:\n", file)
		flag.PrintDefaults()
	}
	if mode == "" {
		flag.Usage()
		os.Exit(0)
	}
	if inputFile == "" {
		if flag.Arg(0) == "" {
			flag.Usage()
			os.Exit(0)
		}
		inputFile = flag.Arg(0)
	}
	if outputFile == "" {
		outputFile = createName()
	}

	mimetype.SetLimit(2 >> 15)
}

func main() {
	switch strings.ToLower(mode) {
	case "z", "0", "zero":
		webm([]byte{0, 0, 0, 0, 0, 0, 0, 0})
	case "n", "-", "negative":
		webm([]byte{66, 255, 176, 96, 0, 0, 0, 0})
	case "e", "+", "expanding":
		webm([]byte{63, 240, 0, 0, 0, 0, 0, 0})

	default:
		logRed.Println("Wrong mode!")
	}

	switch <-done {
	case responseWrongFileType:
		logRed.Println("Wrong File Type")
	case responseFileNotExist:
		logRed.Println("File Not Found")
	case responseDone:
		logGreen.Printf("Done, saved to %s", outputFile)
	}
	time.Sleep(time.Second * 5)
}

func webm(change []byte) {
	b, err := os.ReadFile(inputFile)
	if err != nil {
		logRed.Sprintln("File could not be opened")
		done <- responseFileNotExist
		return
	}

	mime := mimetype.Detect(b).String()
	if mime != "video/webm" && mime != "video/x-matroska" {
		done <- responseWrongFileType
	}

	index := bytes.Index(b, []byte("\x44\x89\x88"))
	if index == -1 {
		done <- responseUnknownError
		return
	}

	if filepath.Ext(outputFile) == "" {
		outputFile = outputFile + ".webm"
	}

	os.WriteFile(outputFile, bytes.Replace(b, b[index+3:index+10], change, 1), 0o777)

	done <- responseDone
}

func createName() string {
	charset := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, 8)
	rand.Seed(time.Now().UnixNano())
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}
